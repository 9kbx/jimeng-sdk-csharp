using System.Text.Json;
using JimengSDK.Requests;
using JimengSDK.Responses;
using Microsoft.Extensions.Logging;

namespace JimengSDK;

/// <summary>
/// 即梦AI接口
/// </summary>
/// <remarks>官方文档：https://www.volcengine.com/docs/85621/1747301</remarks>
public class JimengClient
{
    private readonly ILogger<JimengClient> _logger;
    private readonly HttpClient _httpClient;
    private readonly JimengOptions _options;
    private readonly SignatureTool _signatureTool;

    public JimengClient(JimengOptions options, HttpClient httpClient, ILogger<JimengClient> logger)
    {
        _options = options;
        _httpClient = httpClient;
        _logger = logger;

        _signatureTool = new SignatureTool(_options.Region, _options.Service, _options.Schema, _options.Endpoint,
            _options.Path, _options.AccessKeyId, _options.AccessKeySecret);
    }

    /// <summary>
    /// 创建图生图(3.0)任务
    /// </summary>
    /// <param name="prompt">用于编辑图像的提示词</param>
    /// <param name="binaryDataBase64">图片文件base64编码，需输入1张图片; 与url二选一</param>
    /// <param name="imageUrls">图片文件URL，需输入1张图片；与base64data二选一</param>
    /// <param name="width">生成图像宽高，系统默认生成1328 * 1328的图像,支持自定义生成图像宽高，范围在[512, 2016]内；推荐可选的宽高比：1328 * 1328（1:1）/1472 * 1104 （4:3）/1584 * 1056（3:2）/1664 * 936（16:9）/2016 * 864（21:9）</param>
    /// <param name="height">生成图像宽高，需同时传width和height才会生效；如果自定义生图宽高都比1024小很多（如：600以下）可能出图全黑，建议优先设置接近1024的生图宽高； <br/>最终输出图宽高与传入宽高相关但不完全相等，为“与传入宽高最接近16整数倍”的像素值，范围在 [512, 1536] 内；</param>
    /// <param name="seed">随机种子，作为确定扩散初始状态的基础，默认-1（随机）。若随机种子为相同正整数且其他参数均一致，则生成内容极大概率效果一致</param>
    /// <param name="scale">文本描述影响的程度，该值越大代表文本描述影响程度越大，且输入图片影响程度越小<br/>默认值：0.5<br/>取值范围：[0, 1]</param>
    /// <returns></returns>
    public async Task<JimengResponse<ImageToImageData>> ImageToImageV3Async(string prompt,
        ICollection<string> binaryDataBase64,
        ICollection<string> imageUrls, int width = 1024, int height = 1024, int seed = -1, float scale = 0.5f)
    {
        var body = ImageToImageV3Request.GetRequestBodyBytes(prompt, binaryDataBase64, imageUrls, width, height, seed,
            scale);
        var queryList = new SortedDictionary<string, string>();
        // queryList.Add("X-Expires","900"); // 签名的有效时间(可选)，单位为秒，不填时默认值为900。

        using var httpRequest = _signatureTool.CreateHttpRequestMessage("POST", queryList, body, DateTimeOffset.UtcNow,
            "CVSync2AsyncSubmitTask",
            "2022-08-31");

        var response = await _httpClient.SendAsync(httpRequest);
        var responseBody = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<JimengResponse<ImageToImageData>>(responseBody);
    }

    /// <summary>
    /// 获取图生图(3.0)任务状态
    /// </summary>
    /// <param name="taskId">任务ID，此字段的取值为提交任务接口的返回</param>
    /// <param name="returnUrl">输出是否返回图片链接 （链接有效期为24小时）</param>
    /// <param name="addLogo">是否添加水印信息</param>
    /// <param name="position">水印的位置，取值如下：0-右下角/1-左下角/2-左上角/3-右上角/默认0</param>
    /// <param name="language">水印的语言，取值如下：0-中文（AI生成）/1-英文（Generated by AI）/默认0</param>
    /// <param name="opacity">水印的不透明度，取值范围0-1，1表示完全不透明，默认0.3</param>
    /// <param name="logoTextContent">明水印自定义内容</param>
    /// <returns></returns>
    public async Task<JimengResponse<GetImageToImageResultData>> GetImageToImageV3ResultAsync(
        string taskId, bool returnUrl = false, bool addLogo = false,
        int position = 0, int language = 0, float opacity = 0.3f, string logoTextContent = "")
    {
        var body = GetImageToImageV3ResultRequest.ToRequestBodyBytes(taskId, returnUrl, addLogo, position, language,
            opacity, logoTextContent);
        var queryList = new SortedDictionary<string, string>();
        // queryList.Add("X-Expires","900"); // 签名的有效时间(可选)，单位为秒，不填时默认值为900。
        using var httpRequest = _signatureTool.CreateHttpRequestMessage("POST", queryList, body, DateTimeOffset.UtcNow,
            "CVSync2AsyncGetResult",
            "2022-08-31");

        var response = await _httpClient.SendAsync(httpRequest);
        var responseBody = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<JimengResponse<GetImageToImageResultData>>(responseBody);
    }
}